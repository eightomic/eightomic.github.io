<!DOCTYPE html><html lang="en"><head><title>Eightomic: 32-Bit Non-Cryptographic Hash</title><link href="https://eightomic.com/32-bit-hash/" rel="canonical"><link href="/favicon.ico?1111111111" rel="icon" type="image/x-icon"><meta content="initial-scale=1,width=device-width" name="viewport"><meta charset="utf-8"><style type="text/css">a{color:#000;font-weight:bold;letter-spacing:-0.1px;text-decoration:none;transition:opacity 0.2s ease;}a:hover{opacity:0.9;}body,html{background:#fafafa;color:#000;font-family:sans-serif;font-size:14px;font-weight:normal;line-height:23px;margin:0;overflow-x:hidden;width:100%;}code{background:#f3f3f3 !important;border:2px solid #bcbcbc !important;border-radius:4px;box-sizing:border-box !important;color:#222;display:inline-block;font-family:monospace !important;font-size:11px;font-weight:normal;height:auto;line-height:18px !important;margin:6px 0 16px;max-height:800px;overflow-x:scroll;padding:30px 31px 25px !important;white-space:pre;width:100% !important;}footer{display:inline-block;margin:100px 0;width:100%;}footer ul{display:inline-block;}footer ul{margin:55px 0 0;padding:0;width:100%;}footer ul li{display:inline-block;float:left;line-height:18px;margin:0 15px 5px 0;}footer ul li a{font-size:12px;float:left;}footer .social-media a{display:block;float:left;}footer .social-media a img{height:16px;}h1,h2,h3 {display:inline-block;font-weight:normal;text-transform:uppercase;width:100%;}h1{font-size:23px;letter-spacing:-0.7px;line-height:32px;margin:-6px 0 29px;}h2{font-size:19px;letter-spacing:-0.6px;line-height:42px;margin:0 0 16px;padding-top:18px;}h3{font-size:14px;letter-spacing:-0.2px;margin:13px 0 20px;}p{box-sizing:border-box;color:#555;display:inline-block;margin:0 0 15px;width:100%;}p .code,ul .code{background:#f3f3f3;border:2px solid #bcbcbc;border-radius:4px;color:#222;display:inline-block;font-family:monospace;font-size:11px;font-weight:normal;line-height:16px;margin:2px 1px;padding:4px 5px 0;}ul{list-style:none;margin:0;padding:0;}ul li{color:#555;margin-bottom:15px;}.eightomic-icon{float:left;margin:0 15px 9px 0;}.eightomic-icon img{float:left;height:32px !important;margin:-3px 0 0;}.game{background:#000;border-radius:5px;box-sizing:border-box;margin:0 0 30px;padding:21px 32px;position:relative;transition:opacity 0.2s ease;}.game:hover {opacity:0.9;}.game.no-margin-top{margin-top:10px !important;}.game a{border-radius:5px;height:100%;left:0;position:absolute;text-indent:-9999px;top:0;width:100%;}.game img{display:block;height:32px;margin:12px 0 0;width:32px;}.game h3{color:#fff;font-weight:bold;line-height:30px;margin:17px 0 0;}.game p{color:#999;margin-bottom:0;}.game .version{color:#f02222;display:block;font-size:12px;font-weight:bold;margin:5px 0 3px;}.no-margin-bottom{margin-bottom:0 !important;}.no-margin-left{margin-left:0 !important;}.no-margin-top{margin-top:0 !important;}.section{margin-bottom:40px;position:relative;}</style></head><body><div style="box-sizing:border-box;margin:0 auto;max-width:720px;padding:0 25px;width:100%;"><header style="display:inline-block;padding:105px 0 70px;width:100%;"><a class="eightomic-icon" href="/"><img src="/icon-eightomic.jpg"></a></header><main style="min-height:280px;width:100%;"><h1>32-Bit Non-Cryptographic Hash: A Fast, Non-Multiplicative, Security-Centric Hashing Algorithm Without 64-Bit Arithmetic or Unaligned Memory</h1><div class="section"><p class="no-margin-bottom">Eightomic developed a 32-bit hashing algorithm with a library in C99 as a substantial improvement to CityHash32 v1.1, MurmurHash3, SipHash32 and XXHash32.</p></div><div class="section"><h2>Library</h2><h3 class="no-margin-top">Source</h3><code>#include &lt;stdint.h&gt;
#include &lt;string.h&gt;

struct eightomic_hash_32_s {
  uint32_t a;
  uint32_t b;
  uint32_t c;
  uint32_t d;
  uint32_t e;
  uint32_t f;
  uint32_t g;
  uint32_t h;
  uint32_t _state;
  uint32_t state;
  unsigned long _input_count;
};

uint32_t read_32(uint8_t *input, unsigned long i) {
  uint32_t _input;

  memcpy(&_input, &input[i], sizeof(_input));
  return _input;
}

void eightomic_hash_32_initialize(struct eightomic_hash_32_s *s) {
  s->a = 1;
  s->b = 11;
  s->c = 111;
  s->d = 1111;
  s->e = 11111;
  s->f = 111111;
  s->g = 1111111;
  s->h = 11111111;
  s->_state = 111111111;
  s->state = 1111111111;
  s->_input_count = 0;
}

void eightomic_hash_32_transform(unsigned long i, unsigned long input_count,
                                 const uint8_t *input,
                                 struct eightomic_hash_32_s *s) {
  if (input_count >= 32) {
    i = 31;

    while (i < input_count) {
      s->_state = s->state;
      s->state += s->a + s->b + s->c + s->d + s->e + s->f + s->g + s->h;
      s->a += read_32(input, i - 3) + ((s->a << 8) | (s->a >> 24)) + s->_state
        + 1;
      s->b += read_32(input, i - 7) + ((s->b << 9) | (s->b >> 23)) + s->_state
        + 11;
      s->c += read_32(input, i - 11) + ((s->c << 10) | (s->c >> 22)) + s->_state
        + 111;
      s->d += read_32(input, i - 15) + ((s->d << 11) | (s->d >> 21)) + s->_state
        + 1111;
      s->e += read_32(input, i - 19) + ((s->e << 12) | (s->e >> 20)) + s->_state
        + 11111;
      s->f += read_32(input, i - 23) + ((s->f << 13) | (s->f >> 19)) + s->_state
        + 111111;
      s->g += read_32(input, i - 27) + ((s->g << 14) | (s->g >> 18)) + s->_state
        + 1111111;
      s->h += read_32(input, i - 31) + ((s->h << 15) | (s->h >> 17)) + s->_state
        + 11111111;
      i += 32;
    }

    if (i >= input_count) {
      i -= 32;
    }

    s->_state += s->a + s->b + s->c + s->d + s->e + s->f + s->g + s->h;
    i++;
  }

  if ((input_count - i) >= 16) {
    i += 16;
    s->_state += s->state;
    s->state += s->a + s->b + s->c + s->d + s->e;
    s->a += read_32(input, i - 16) + ((s->a << 8) | (s->a >> 24)) + s->_state
      + 1;
    s->b += read_32(input, i - 12) + ((s->b << 9) | (s->b >> 23)) + s->_state
      + 11;
    s->c += read_32(input, i - 8) + ((s->c << 10) | (s->c >> 22)) + s->_state
      + 111;
    s->d += read_32(input, i - 4) + ((s->d << 11) | (s->d >> 21)) + s->_state
      + 1111;
  }

  if ((input_count - i) >= 8) {
    i += 8;
    s->_state += s->state;
    s->state += s->a + s->b + s->c;
    s->a += read_32(input, i - 8) + ((s->a << 8) | (s->a >> 24)) + s->_state
      + 1;
    s->b += read_32(input, i - 4) + ((s->b << 9) | (s->b >> 23)) + s->_state
      + 11;
  }

  s->_input_count += input_count;

  if (i != input_count) {
    s->state += s->_state + ((s->a << 8) | (s->a >> 24));
    input_count -= i;

    if (input_count >= 4) {
      s->a += s->state + read_32(input, i) + 1111111111;

      if (input_count != 4) {
        s->_state += s->a + s->b;
        s->state += s->_state + ((s->b << 10) | (s->b >> 22));

        if (input_count == 7) {
          s->b += s->state + (input[i + 4] | (input[i + 5] << 8)
            | (input[i + 6] << 16)) + 1111111;
        } else {
          if (input_count == 6) {
            s->b += s->state + (input[i + 4] | (input[i + 5] << 8)) + 111111;
          } else {
            s->b += s->state + input[i + 4] + 11111;
          }
        }
      }
    } else {
      if (input_count == 3) {
        s->a += s->state + (input[i] | (input[i + 1] << 8)
          | (input[i + 2] << 16)) + 111;
      } else {
        if (input_count == 2) {
          s->a += s->state + (input[i] | (input[i + 1] << 8)) + 11;
        } else {
          s->a += s->state + input[i] + 1;
        }
      }
    }
  }
}

void eightomic_hash_32_finalize(struct eightomic_hash_32_s *s) {
  s->a += s->_state;
  s->state += (s->a << 8) | (s->a >> 24);
  s->b += s->_state ^ s->state;
  s->state += (s->b << 9) | (s->b >> 23);

  if (s->_input_count >= 16) {
    s->c += s->_state + s->state;
    s->state += (s->c << 10) | (s->c >> 22);
    s->d += s->state;
    s->state += (s->d << 11) | (s->d >> 21);

    if (s->_input_count >= 32) {
      s->e += s->state;
      s->state += (s->e << 12) | (s->e >> 20);
      s->f += s->state;
      s->state += (s->f << 13) | (s->f >> 19);
      s->g += s->state;
      s->state += (s->g << 14) | (s->g >> 18);
      s->h += s->a + s->state;
      s->state += ((s->h << 15) | (s->h >> 17)) + s->_state;
    }
  }

  s->_state += s->state + s->_input_count;
  s->state += ((s->a << 13) | (s->a >> 19)) ^ s->h;
  s->b += s->state;
  s->state += s->a ^ ((s->b << 14) | (s->b >> 18));
  s->c += s->_state ^ s->state;
  s->state += s->b ^ ((s->c << 15) | (s->c >> 17));
  s->d += s->_state + s->state;
  s->state += s->c ^ ((s->d << 17) | (s->d >> 15));
  s->_state += s->state;
  s->e += s->_state ^ s->state;
  s->state += s->d ^ ((s->e << 18) | (s->e >> 14));
  s->f += s->_state + s->state;
  s->state += s->e ^ ((s->f << 19) | (s->f >> 13));
  s->g += s->state;
  s->state += s->f ^ ((s->g << 20) | (s->g >> 12));
  s->h += s->state;
  s->state += (s->g ^ ((s->h << 21) | (s->h >> 11))) + s->_state;
}</code><h3>Reference</h3><p><span class="code no-margin-left">eightomic_hash_32_initialize()</span> is the initialization function that accepts the following argument.</p><p><span class="code no-margin-left">s</span> is a <span class="code">struct eightomic_hash_32_s</span> pointer.</p><p><span class="code no-margin-left">eightomic_hash_32_transform()</span> is the core hashing loop that accepts the 4 following arguments.</p><p><span class="code no-margin-left">i</span> is the starting index position of elements in the <span class="code">input</span> array.</p><p><span class="code no-margin-left">input_count</span> is the count of elements in the <span class="code">input</span> array. When hashing in split segments, the value must be a multiple of 32, with the exception of the end segment.</p><p><span class="code no-margin-left">input</span> is the <span class="code">const uint8_t</span> array to hash.</p><p><span class="code no-margin-left">s</span> is a <span class="code">struct eightomic_hash_32_s</span> pointer.</p><p><span class="code no-margin-left">eightomic_hash_32_finalize()</span> is the finalization function that accepts the following argument.</p><p><span class="code no-margin-left">s</span> is a <span class="code">struct eightomic_hash_32_s</span> pointer. <span class="code">s.state</span> contains the finalized hash digest result.</p><p>The return value data type is <span class="code">void</span>.</p><h3>Requirements</h3><p>C compiler with C99 (ISO/IEC 9899:1999) standard compatibility.</p><p class="no-margin-bottom">CPU with single-threaded, instruction-level parallelism support.</p></div><div class="section"><h2>Explanation</h2><p>This 32-bit non-cryptographic hashing algorithm is designed to hash keys of all sizes in data structures without hidden security issues such as excess collisions, hashDoS vulnerability, poor distribution and slow speeds.</p><p>It has speed properties similar to XXHash32 with security properties similar to SipHash.</p><p>It's portable for both 32-bit and 64-bit systems. There's an alternative <a href="/64-bit-hash/">64-bit hashing algorithm</a> for 64-bit systems that outperforms the aforementioned 32-bit hashing algorithm with good high and low 32-bit results.</p><p>It meets strict compliance, portability and security requirements.</p><p>Memory reading is designed for systems with little-endian byte order, although big-endian memory reading is functional with similar results.</p><p>In the rare case when hash table states must be saved after program termination and re-used in multiple systems with varying endianness, keys should be re-hashed during initialization instead of slowing down runtime hashing with byte order alignment.</p><p>It doesn't use modulus, multiplication or division arithmetic operations.</p><p>It supports unlimited input length by splitting <span class="code">input</span> bytes into descending segments of 256, 128, 64 and the remaining 8–63 bits. All-at-once hashing isn't required and the digest results are consistent when hashing in partial segments.</p><p>Single-threaded, instruction-level parallelism with low-cost addition and bitwise instructions work well on a wide range of CPU queue loads and devices.</p><p>The staggered additive constants, summed with <span class="code">s->a</span> through <span class="code">s->h</span>, eliminate any possible vulnerability to <span class="code">input</span> elements with a <span class="code">0</span> value.</p><p>Not allowing a seed secures the possibility of 2^32 deterministic attacks, so all seed-based tests were omitted.</p><p>It passes all extended SMHasher excessive torture tests that don't require a seed and it's likely to pass new tests as they're released.</p><p>Most of the tests passed beyond the default extended limit. For example, avalanche tests passed with 2000-bit, 3000-bit and 3501-bit inputs.</p><p>Compared to CityHash and MurmurHash, the speed's approximately 25% to 54% faster on average for varying input lengths.</p><p>Furthermore, CityHash fails some SMHasher tests, including the avalanche test.</p><p>Compared to SipHash, the speed's at least 400% faster on average with the similar absence of cryptanalytic vulnerabilities using 320 auxiliary bits of preimage attack security.</p><p>Compared to XXHash32, the speed's similar on average for varying input lengths without failing SMHasher tests.</p><p>Furthermore, it's the only hashing algorithm that doesn't use multiplication operations out of the 4 compared hashing algorithms.</p><p>As with the other hashing functions in SMHasher, it was tested with the following all-at-once hashing function instead of the slower segmented functions from the aforementioned library code.</p><code class="no-margin-bottom">#include &lt;stdint.h&gt;
#include &lt;string.h&gt;

uint32_t read_32(const uint8_t *input, unsigned long i) {
  uint32_t _input;

  memcpy(&_input, &input[i], sizeof(_input));
  return _input;
}

uint32_t eightomic_hash_32(unsigned long input_count, const uint8_t *input) {
  uint32_t a = 1;
  uint32_t b = 11;
  uint32_t c = 111;
  uint32_t d = 1111;
  uint32_t e = 11111;
  uint32_t f = 111111;
  uint32_t g = 1111111;
  uint32_t h = 11111111;
  unsigned long i = 0;
  uint32_t _state = 111111111;
  uint32_t state = 1111111111;
  unsigned long _input_count = 0;

  if (input_count >= 32) {
    i = 31;

    while (i < input_count) {
      _state = state;
      state += a + b + c + d + e + f + g + h;
      a += read_32(input, i - 3) + ((a << 8) | (a >> 24)) + _state + 1;
      b += read_32(input, i - 7) + ((b << 9) | (b >> 23)) + _state + 11;
      c += read_32(input, i - 11) + ((c << 10) | (c >> 22)) + _state + 111;
      d += read_32(input, i - 15) + ((d << 11) | (d >> 21)) + _state + 1111;
      e += read_32(input, i - 19) + ((e << 12) | (e >> 20)) + _state + 11111;
      f += read_32(input, i - 23) + ((f << 13) | (f >> 19)) + _state + 111111;
      g += read_32(input, i - 27) + ((g << 14) | (g >> 18)) + _state + 1111111;
      h += read_32(input, i - 31) + ((h << 15) | (h >> 17)) + _state + 11111111;
      i += 32;
    }

    if (i >= input_count) {
      i -= 32;
    }

    _state += a + b + c + d + e + f + g + h;
    i++;
  }

  if ((input_count - i) >= 16) {
    i += 16;
    _state += state;
    state += a + b + c + d + e;
    a += read_32(input, i - 16) + ((a << 8) | (a >> 24)) + _state + 1;
    b += read_32(input, i - 12) + ((b << 9) | (b >> 23)) + _state + 11;
    c += read_32(input, i - 8) + ((c << 10) | (c >> 22)) + _state + 111;
    d += read_32(input, i - 4) + ((d << 11) | (d >> 21)) + _state + 1111;
  }

  if ((input_count - i) >= 8) {
    i += 8;
    _state += state;
    state += a + b + c;
    a += read_32(input, i - 8) + ((a << 8) | (a >> 24)) + _state + 1;
    b += read_32(input, i - 4) + ((b << 9) | (b >> 23)) + _state + 11;
  }

  _input_count += input_count;

  if (i != input_count) {
    state += _state + ((a << 8) | (a >> 24));
    input_count -= i;

    if (input_count >= 4) {
      a += state + read_32(input, i) + 1111111111;

      if (input_count != 4) {
        _state += a + b;
        state += _state + ((b << 10) | (b >> 22));

        if (input_count == 7) {
          b += state + (input[i + 4] | (input[i + 5] << 8)
            | (input[i + 6] << 16)) + 1111111;
        } else {
          if (input_count == 6) {
            b += state + (input[i + 4] | (input[i + 5] << 8)) + 111111;
          } else {
            b += state + input[i + 4] + 11111;
          }
        }
      }
    } else {
      if (input_count == 3) {
        a += state + (input[i] | (input[i + 1] << 8)
          | (input[i + 2] << 16)) + 111;
      } else {
        if (input_count == 2) {
          a += state + (input[i] | (input[i + 1] << 8)) + 11;
        } else {
          a += state + input[i] + 1;
        }
      }
    }
  }

  a += _state;
  state += (a << 8) | (a >> 24);
  b += state ^ _state;
  state += (b << 9) | (b >> 23);

  if (_input_count >= 16) {
    c += _state + state;
    state += (c << 10) | (c >> 22);
    d += state;
    state += (d << 11) | (d >> 21);

    if (_input_count >= 32) {
      e += state;
      state += (e << 12) | (e >> 20);
      f += state;
      state += (f << 13) | (f >> 19);
      g += state;
      state += (g << 14) | (g >> 18);
      h += a + state;
      state += ((h << 15) | (h >> 17)) + _state;
    }
  }

  _state += state + _input_count;
  state += ((a << 13) | (a >> 19)) ^ h;
  b += state;
  state += a ^ ((b << 14) | (b >> 18));
  c += _state ^ state;
  state += b ^ ((c << 15) | (c >> 17));
  d += _state + state;
  state += c ^ ((d << 17) | (d >> 15));
  _state += state;
  e += _state ^ state;
  state += d ^ ((e << 18) | (e >> 14));
  f += _state + state;
  state += e ^ ((f << 19) | (f >> 13));
  g += state;
  state += f ^ ((g << 20) | (g >> 12));
  h += state;
  return (g ^ ((h << 21) | (h >> 11))) + state + _state;
}</code></div><div class="no-margin-bottom section"><h2>Games</h2><div class="game no-margin-bottom no-margin-top"><a href="/contrivity/">Contrivity</a><img alt="Contrivity Icon" src="/icon-contrivity.jpg"><h3>Contrivity</h3><p>Spawn into the hostile quantum laboratory and destroy wave after wave of oscillations.</p><span class="version">v1.0.14</span></div></div></main><footer><div class="no-margin-bottom"><p><a class="eightomic-icon" href="/"><img src="/icon-eightomic.jpg"></a> &copy; 2024 Eightomic</p><ul><li><a href="/about/">About</a></li><li><a href="/contact/">Contact</a></li><li><a href="/#games">Games</a></li><li><a href="/privacy-policy/">Privacy Policy</a></li><li><a href="/#research">Research</a></li><li><a href="/terms/">Terms</a></li></ul><ul class="social-media"><li><a href="https://github.com/eightomic" target="_blank"><img src="/icon-github.jpg"></a></li><li><a href="https://www.instagram.com/eightomic" target="_blank"><img src="/icon-instagram.jpg"></a></li><li><a href="https://www.reddit.com/r/eightomic/" target="_blank"><img src="/icon-reddit.jpg"></a></li><li><a href="https://www.tiktok.com/@eightomic" target="_blank"><img src="/icon-tiktok.jpg"></a></li><li><a href="https://x.com/eightomic" target="_blank"><img src="/icon-x.jpg"></a></li><li><a href="https://www.youtube.com/@eightomic" target="_blank"><img src="/icon-youtube.jpg"></a></li></ul><p style="color: #777; font-size: 12px; line-height: 19px; margin: 52px 0 0;">All depictions of danger and violence in Eightomic games are for fictional gaming entertainment purposes only. Some Eightomic games may have frantic animations with non-realistic blood and gore graphical effects which may cause discomfort and seizures for players with epilepsy or other sensitivity disorders. Prolongued periods of looking at a computer screen and typing on a keyboard are discouraged to prevent health issues such as carpal tunnel syndrome.</p></div></footer></div></body></html>
