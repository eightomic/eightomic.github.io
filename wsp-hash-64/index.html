<!DOCTYPE html><html lang="en"><head><title>WSP-Hash-64</title><link href="https://williamstaffordparsons.github.io/wsp-hash-64/" rel="canonical"><link href="/favicon.ico?1111111111" rel="icon" type="image/x-icon"><meta content="initial-scale=1,width=device-width" name="viewport"><meta charset="utf-8"><style type="text/css">a{color:#000;font-weight:bold;letter-spacing:-0.1px;text-decoration:none;transition:opacity 0.2s ease;}a:hover{opacity:0.9;}body,html{background:#fafafa;color:#000;font-family:sans-serif;font-size:14px;font-weight:normal;line-height:23px;margin:0;overflow-x:hidden;width:100%;}code{background:#f3f3f3 !important;border:2px solid #bcbcbc !important;border-radius:4px;box-sizing:border-box !important;color:#222;display:inline-block;font-family:monospace !important;font-size:11px;font-weight:normal;height:auto;line-height:18px !important;margin:6px 0 16px;max-height:800px;overflow-x:scroll;padding:30px 31px 25px !important;white-space:pre;width:100% !important;}footer{display:inline-block;margin:100px 0;width:100%;}footer ul{display:inline-block;}footer ul{margin:55px 0 0;padding:0;width:100%;}footer ul li{display:inline-block;float:left;line-height:18px;margin:0 15px 5px 0;}footer ul li a{font-size:12px;float:left;}footer .social-media a{display:block;float:left;}footer .social-media a img{height:16px;}h1,h2,h3{display:inline-block;font-weight:normal;text-transform:uppercase;width:100%;}h1{font-size:23px;letter-spacing:-0.7px;line-height:32px;margin:-6px 0 29px;}h2{font-size:19px;letter-spacing:-0.6px;line-height:42px;margin:0 0 16px;padding-top:18px;}h3{font-size:14px;letter-spacing:-0.2px;margin:13px 0 20px;}p{box-sizing:border-box;color:#555;display:inline-block;margin:0 0 15px;width:100%;}p .code,ul .code{background:#f3f3f3;border:2px solid #bcbcbc;border-radius:4px;color:#222;display:inline-block;font-family:monospace;font-size:11px;font-weight:normal;line-height:16px;margin:2px 1px;padding:4px 5px 0;}ul{list-style:none;margin:0;padding:0;}ul li{color:#555;margin-bottom:15px;}.game{background:#000;border-radius:5px;box-sizing:border-box;margin:0 0 30px;padding:21px 32px;position:relative;transition:opacity 0.2s ease;}.game:hover {opacity:0.9;}.game.no-margin-top{margin-top:5px !important;}.game a{border-radius:5px;height:100%;left:0;position:absolute;text-indent:-9999px;top:0;width:100%;}.game img{display:block;height:32px;margin:12px 0 0;width:32px;}.game h3{color:#fff;font-weight:bold;line-height:30px;margin:17px 0 0;}.game p{color:#999;margin-bottom:0;}.game .version{color:#f02222;display:block;font-size:12px;font-weight:bold;margin:5px 0 3px;}.no-margin-bottom{margin-bottom:0 !important;}.no-margin-left{margin-left:0 !important;}.no-margin-top{margin-top:0 !important;}.section{margin-bottom:40px;position:relative;}.william-stafford-parsons-icon{float:left;margin:0 15px 9px 0;}.william-stafford-parsons-icon img{float:left;height:32px !important;margin:-3px 0 0;}</style></head><body><div style="box-sizing:border-box;margin:0 auto;max-width:720px;padding:0 25px;width:100%;"><header style="display:inline-block;padding:105px 0 70px;width:100%;"><a class="william-stafford-parsons-icon" href="/"><img src="/icon-william-stafford-parsons.jpg"></a></header><main style="min-height:280px;width:100%;"><h1>WSP-Hash-64: A Fast, Non-Cryptographic, Non-Multiplicative, Security-Centric 64-Bit Hashing Algorithm With Good High and Low 32-Bit Segments</h1><div class="section"><p class="no-margin-bottom"><a href="/about/">William Stafford Parsons</a> developed a 64-bit hashing algorithm with a library in C99 as a substantial improvement to CityHash64, MurmurHash3, SipHash and SpookyHashV2.</p></div><div class="section"><h2>Library</h2><h3 class="no-margin-top">Source</h3><code>#include &lt;stdint.h&gt;
#include &lt;string.h&gt;

uint32_t read_32(const uint8_t *input, unsigned long i) {
  uint32_t _input;

  memcpy(&_input, &input[i], sizeof(_input));
  return _input;
}

uint64_t read_64(const uint8_t *input, unsigned long i) {
  uint64_t _input;

  memcpy(&_input, &input[i], sizeof(_input));
  return _input;
}

struct wsp_hash_64_s {
  uint64_t a;
  uint64_t b;
  uint64_t c;
  uint64_t d;
  uint64_t _state;
  uint64_t state;
};

void wsp_hash_64_initialize(struct wsp_hash_64_s *s) {
  s->a = 1;
  s->b = 11;
  s->c = 111;
  s->d = 1111;
  s->_state = 1111111111;
  s->state = 11111111111;
}

void wsp_hash_64_transform(unsigned long i, unsigned long input_count,
                           const uint8_t *input,
                           struct wsp_hash_64_s *s) {
  uint64_t _a;
  uint64_t _b;
  uint64_t _c;
  uint64_t _d;

  if (input_count >= 32) {
    i = 31;

    while (i < input_count) {
      _a = read_64(input, i - 7);
      _b = read_64(input, i - 15);
      _c = read_64(input, i - 23);
      _d = read_64(input, i - 31);
      s->state += _a + _b + _c + _d;
      s->a += ((s->a << 30) | (s->a >> 34)) + s->state + _a + 1;
      s->b += ((s->b << 29) | (s->b >> 35)) + s->state + _b + 11;
      s->c += ((s->c << 28) | (s->c >> 36)) + _c + 111;
      s->d += ((s->d << 27) | (s->d >> 37)) + _d + 1111;
      i += 32;
    }

    if (i >= input_count) {
      i -= 32;
    }

    s->state += s->a + s->b + s->c + s->d;
    i++;
    input_count -= i;
  }

  if (input_count >= 16) {
    input_count -= 16;
    i += 16;
    _a = read_64(input, i - 16);
    _b = read_64(input, i - 8);
    s->state += _a + _b;
    s->a += ((s->a << 30) | (s->a >> 34)) + s->state + _a + 1;
    s->b += ((s->b << 29) | (s->b >> 35)) + s->state + _b + 11;
  }

  if (input_count >= 8) {
    input_count -= 8;
    i += 8;
    _a = read_64(input, i - 8);
    s->state += _a;
    s->a += ((s->a << 30) | (s->a >> 34)) + s->state + _a + 1;
  }

  if (input_count != 0) {
    s->state += ((s->a << 16) | (s->a >> 48)) + s->_state;

    if (input_count >= 4) {
      s->a += read_32(input, i) + s->state + 1111111111;

      if (input_count != 4) {
        s->_state += s->a + s->b;
        s->state += ((s->b << 20) | (s->b >> 44)) + s->_state;

        if (input_count == 7) {
          s->b += (input[i + 4] | (input[i + 5] << 8)
            | (input[i + 6] << 16)) + s->state + 111111111;
        } else {
          if (input_count == 6) {
            s->b += (input[i + 4] | (input[i + 5] << 8)) + s->state + 11111111;
          } else {
            s->b += input[i + 4] + s->state + 1111111;
          }
        }
      }
    } else {
      if (input_count == 3) {
        s->a += (input[i] | (input[i + 1] << 8)
          | (input[i + 2] << 16)) + s->state + 111111;
      } else {
        if (input_count == 2) {
          s->a += (input[i] | (input[i + 1] << 8)) + s->state + 1111;
        } else {
          s->a += input[i] + s->state + 11;
        }
      }
    }
  }
}

void wsp_hash_64_finalize(struct wsp_hash_64_s *s) {
  s->a += s->_state;
  s->state += (s->a << 36) | (s->a >> 28);
  s->b += s->_state ^ s->state;
  s->state += (s->b << 38) | (s->b >> 26);
  s->c += s->_state + s->state;
  s->state += (s->c << 40) | (s->c >> 24);
  s->d += (s->a + s->b + s->c) ^ s->state;
  s->state += (s->d << 42) | (s->d >> 22);
  s->_state += s->state;
  s->b += s->a + s->state;
  s->state += (s->b << 28) | (s->b >> 36);
  s->c += s->b + (s->_state ^ s->state);
  s->state += (s->c << 30) | (s->c >> 34);
  s->d += s->c ^ (s->_state + s->state);
  s->state += (s->d << 34) | (s->d >> 30);
  s->a += s->_state;
  s->state += (s->a << 36) | (s->a >> 28);
  s->b += s->_state + s->state;
  s->state += (s->b << 38) | (s->b >> 26);
  s->c += s->_state ^ s->state;
  s->state += (s->c << 40) | (s->c >> 24);
  s->d += (s->a + s->b) ^ s->state;
  s->state += (s->d << 42) | (s->d >> 22);
  s->state = (s->c + s->d) ^ (s->_state + s->state);
}</code><h3>Reference</h3><p><span class="code no-margin-left">wsp_hash_64_initialize()</span> is the initialization function that accepts the following argument.</p><p><span class="code no-margin-left">s</span> is a <span class="code">struct wsp_hash_64_s</span> pointer.</p><p><span class="code no-margin-left">wsp_hash_64_transform()</span> is the core hashing loop that accepts the 4 following arguments.</p><p><span class="code no-margin-left">i</span> is the starting index position of elements in the <span class="code">input</span> array.</p><p><span class="code no-margin-left">input_count</span> is the count of elements in the <span class="code">input</span> array. When hashing in split segments, the value must be a multiple of 32, with the exception of the end segment.</p><p><span class="code no-margin-left">input</span> is the <span class="code">const uint8_t</span> array to hash.</p><p><span class="code no-margin-left">s</span> is a <span class="code">struct wsp_hash_64_s</span> pointer.</p><p><span class="code no-margin-left">wsp_hash_64_finalize()</span> is the finalization function that accepts the following argument.</p><p><span class="code no-margin-left">s</span> is a <span class="code">struct wsp_hash_64_s</span> pointer. <span class="code">s.state</span> contains the finalized hash digest result.</p><p>The return value data type is <span class="code">void</span>.</p><h3>Requirements</h3><p>C compiler with C99 (ISO/IEC 9899:1999) standard compatibility.</p><p class="no-margin-bottom">CPU with single-threaded, instruction-level parallelism support.</p></div><div class="section"><h2>Explanation</h2><p>WSP-Hash-64 is designed to hash keys of all sizes in data structures without hidden security issues such as excess collisions, hashDoS vulnerability, poor distribution and slow speeds.</p><p>It has speed properties similar to CityHash64 and SpookyHashV2 with security properties similar to SipHash.</p><p>It's portable for 64-bit systems. There's an alternative <a href="/wsp-hash-32/">32-bit hashing algorithm</a> for 32-bit systems, although the 32-bit version is outperformed by the lower or upper 32-bits of the aformentioned 64-bit hashing algorithm.</p><p>It meets strict compliance, portability and security requirements.</p><p>Memory reading is designed for systems with little-endian byte order, although big-endian memory reading is functional with similar results.</p><p>In the rare case when hash table states must be saved after program termination and re-used in multiple systems with varying endianness, keys should be re-hashed during initialization instead of slowing down runtime hashing with byte order alignment.</p><p>It doesn't use modulus, multiplication or division arithmetic operations.</p><p>It supports unlimited input length by splitting <span class="code">input</span> bytes into descending segments of 256, 128, 64 and the remaining 8–63 bits. All-at-once hashing isn't required and the digest results are consistent when hashing in partial segments.</p><p>Single-threaded, instruction-level parallelism with low-cost addition and bitwise instructions work well on a wide range of CPU queue loads and devices.</p><p>The staggered additive constants, summed with <span class="code">s->a</span> through <span class="code">s->d</span>, eliminate any possible vulnerability to <span class="code">input</span> elements with a <span class="code">0</span> value.</p><p>Not allowing a seed secures the possibility of 2^32 deterministic attacks, so all seed-based tests were omitted.</p><p>It passes all extended SMHasher excessive torture tests that don't require a seed and it's likely to pass new tests as they're released.</p><p>Most of the tests passed beyond the default extended limit. For example, avalanche tests passed with 2000-bit, 3000-bit and 3501-bit inputs.</p><p>The high and low 32-bit segments pass extended tests as well.</p><p>It's compared with the fastest hashing algorithms that aren't dependent on compiler-specific or platform-specific optimizations with heavy macro usage.</p><p>Compared to CityHash64, the speed's approximately 6% faster on average for varying input lengths.</p><p>Furthermore, the low and high 32-bit segments in CityHash64 are lower in quality by a small margin, it relies on multiplication operations, bytes are processed more than once during alignment and there are derivatives from other hashing algorithms such as CRC and MurmurHash.</p><p>Compared to the lower 64 bits of the 128-bit MurmurHash3 variant, the speed's approximately 80% faster on average for varying input lengths without endian dependence, inline functions or undefined behavior from unaligned reads.</p><p>Compared to SipHash, the speed's at least 1000% faster on average with the similar absence of cryptanalytic vulnerabilities using 320 auxiliary bits of preimage attack security.</p><p>Compared to SpookyHashV2, the speed's 9% faster on average for varying input lengths.</p><p>Furthermore, it's faster with aligned memory reads than SpookyHashV2 with unaligned memory reads. When aligned memory reads are required, it's up to 25% faster than SpookyHashV2 on average.</p><p>As with the other hashing functions in SMHasher, WSP-Hash-64 was tested with the following all-at-once hashing function instead of the slower segmented functions from the aforementioned library code.</p><code class="no-margin-bottom">#include &lt;stdint.h&gt;
#include &lt;string.h&gt;

uint32_t read_32(const uint8_t *input, unsigned long i) {
  uint32_t _input;

  memcpy(&_input, &input[i], sizeof(_input));
  return _input;
}

uint64_t read_64(const uint8_t *input, unsigned long i) {
  uint64_t _input;

  memcpy(&_input, &input[i], sizeof(_input));
  return _input;
}

uint64_t wsp_hash_64(unsigned long input_count, const uint8_t *input) {
  uint64_t _a;
  uint64_t _b;
  uint64_t _c;
  uint64_t _d;
  uint64_t a = 1;
  uint64_t b = 11;
  uint64_t c = 111;
  uint64_t d = 1111;
  uint64_t _state = 1111111111;
  uint64_t state = 11111111111;
  unsigned long i = 0;

  if (input_count >= 32) {
    i = 31;

    while (i < input_count) {
      _a = read_64(input, i - 7);
      _b = read_64(input, i - 15);
      _c = read_64(input, i - 23);
      _d = read_64(input, i - 31);
      state += _a + _b + _c + _d;
      a += _a + ((a << 30) | (a >> 34)) + state + 1;
      b += _b + ((b << 29) | (b >> 35)) + state + 11;
      c += _c + ((c << 28) | (c >> 36)) + 111;
      d += _d + ((d << 27) | (d >> 37)) + 1111;
      i += 32;
    }

    if (i >= input_count) {
      i -= 32;
    }

    state += a + b + c + d;
    i++;
    input_count -= i;
  }

  if (input_count >= 16) {
    input_count -= 16;
    i += 16;
    _a = read_64(input, i - 16);
    _b = read_64(input, i - 8);
    state += _a + _b;
    a += _a + ((a << 30) | (a >> 34)) + state + 1;
    b += _b + ((b << 29) | (b >> 35)) + state + 11;
  }

  if (input_count >= 8) {
    input_count -= 8;
    i += 8;
    _a = read_64(input, i - 8);
    state += _a;
    a += _a + ((a << 30) | (a >> 34)) + state + 1;
  }

  if (input_count != 0) {
    state += ((a << 16) | (a >> 48)) + _state;

    if (input_count >= 4) {
      a += read_32(input, i) + state + 1111111111;

      if (input_count != 4) {
        _state += a + b;
        state += ((b << 20) | (b >> 44)) + _state;

        if (input_count == 7) {
          b += (input[i + 4] | (input[i + 5] << 8)
            | (input[i + 6] << 16)) + state + 111111111;
        } else {
          if (input_count == 6) {
            b += (input[i + 4] | (input[i + 5] << 8)) + state + 11111111;
          } else {
            b += input[i + 4] + state + 1111111;
          }
        }
      }
    } else {
      if (input_count == 3) {
        a += (input[i] | (input[i + 1] << 8)
          | (input[i + 2] << 16)) + state + 111111;
      } else {
        if (input_count == 2) {
          a += (input[i] | (input[i + 1] << 8)) + state + 1111;
        } else {
          a += input[i] + state + 11;
        }
      }
    }
  }

  a += _state;
  state += (a << 36) | (a >> 28);
  b += _state ^ state;
  state += (b << 38) | (b >> 26);
  c += _state + state;
  state += (c << 40) | (c >> 24);
  d += (a + b + c) ^ state;
  state += (d << 42) | (d >> 22);
  _state += state;
  b += a + state;
  state += (b << 28) | (b >> 36);
  c += b + (_state ^ state);
  state += (c << 30) | (c >> 34);
  d += c ^ (_state + state);
  state += (d << 34) | (d >> 30);
  a += _state;
  state += (a << 36) | (a >> 28);
  b += _state + state;
  state += (b << 38) | (b >> 26);
  c += _state ^ state;
  state += (c << 40) | (c >> 24);
  d += (a + b) ^ state;
  state += (d << 42) | (d >> 22);
  return (c + d) ^ (_state + state);
}</code></div><div class="no-margin-bottom section"><h2>Games</h2><div class="game no-margin-bottom no-margin-top"><a href="/contrivity/">Contrivity</a><img alt="Contrivity Icon" src="/icon-contrivity.jpg"><h3>Contrivity</h3><p>Spawn into the hostile quantum laboratory and destroy wave after wave of oscillations.</p><span class="version">v1.0.17</span></div></div></main><footer><div class="no-margin-bottom"><p>&copy; 2024 William Stafford Parsons</p><ul><li><a href="/about/">About</a></li><li><a href="/contact/">Contact</a></li><li><a href="/#games">Games</a></li><li><a href="/#research">Research</a></li></ul><ul class="social-media"><li><a href="https://github.com/williamstaffordparsons" target="_blank"><img src="/icon-github.jpg"></a></li><li><a href="https://www.instagram.com/williamstaffordparsons" target="_blank"><img src="/icon-instagram.jpg"></a></li></ul><p style="color:#777;font-size:12px;line-height:19px;margin:52px 0 0;">All depictions of peril in games created and copyrighted by William Stafford Parsons are for fictional gaming entertainment purposes only. Some of the aforementioned games may have frantic animations which may cause discomfort and seizures for players with epilepsy or other sensitivity disorders. Prolongued periods of looking at a computer screen and typing on a keyboard are discouraged to prevent health issues such as carpal tunnel syndrome.</p></div></footer></div></body></html>
