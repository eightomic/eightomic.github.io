<!DOCTYPE html><html lang="en"><head><title>WSP-Hash-OAAT: The Fastest OAAT Hashing Algorithm</title><link href="https://williamstaffordparsons.github.io/wsp-hash-oaat/" rel="canonical"><link href="/favicon.ico?1111111111" rel="icon" type="image/x-icon"><meta content="initial-scale=1,width=device-width" name="viewport"><meta charset="utf-8"><style type="text/css">a{color:#000;font-weight:bold;letter-spacing:-0.1px;text-decoration:none;transition:opacity 0.2s ease;}a:hover{opacity:0.9;}body,html{background:#fafafa;color:#000;font-family:sans-serif;font-size:14px;font-weight:normal;line-height:23px;margin:0;overflow-x:hidden;width:100%;}code{background:#f3f3f3 !important;border:2px solid #bcbcbc !important;border-radius:4px;box-sizing:border-box !important;color:#222;display:inline-block;font-family:monospace !important;font-size:11px;font-weight:normal;height:auto;line-height:18px !important;margin:6px 0 16px;max-height:800px;overflow-x:scroll;padding:30px 31px 25px !important;white-space:pre;width:100% !important;}footer{display:inline-block;margin:100px 0;width:100%;}footer ul{display:inline-block;}footer ul{margin:55px 0 0;padding:0;width:100%;}footer ul li{display:inline-block;float:left;line-height:18px;margin:0 15px 5px 0;}footer ul li a{font-size:12px;float:left;}footer .social-media a{display:block;float:left;}footer .social-media a img{height:16px;}h1,h2,h3{display:inline-block;font-weight:normal;text-transform:uppercase;width:100%;}h1{font-size:23px;letter-spacing:-0.7px;line-height:32px;margin:-6px 0 29px;}h2{font-size:19px;letter-spacing:-0.6px;line-height:42px;margin:0 0 16px;padding-top:18px;}h3{font-size:14px;letter-spacing:-0.2px;margin:13px 0 20px;}p{box-sizing:border-box;color:#555;display:inline-block;margin:0 0 15px;width:100%;}p .code,ul .code{background:#f3f3f3;border:2px solid #bcbcbc;border-radius:4px;color:#222;display:inline-block;font-family:monospace;font-size:11px;font-weight:normal;line-height:16px;margin:2px 1px;padding:4px 5px 0;}ul{list-style:none;margin:0;padding:0;}ul li{color:#555;margin-bottom:15px;}.game{background:#000;border-radius:5px;box-sizing:border-box;margin:0 0 30px;padding:21px 32px;position:relative;transition:opacity 0.2s ease;}.game:hover {opacity:0.9;}.game.no-margin-top{margin-top:5px !important;}.game a{border-radius:5px;height:100%;left:0;position:absolute;text-indent:-9999px;top:0;width:100%;}.game img{display:block;height:32px;margin:12px 0 0;width:32px;}.game h3{color:#fff;font-weight:bold;line-height:30px;margin:17px 0 0;}.game p{color:#999;margin-bottom:5px;}.no-margin-bottom{margin-bottom:0 !important;}.no-margin-left{margin-left:0 !important;}.no-margin-top{margin-top:0 !important;}.section{margin-bottom:40px;position:relative;}.william-stafford-parsons-icon{float:left;margin:0 15px 9px 0;}.william-stafford-parsons-icon img{float:left;height:32px !important;margin:-3px 0 0;}</style></head><body><div style="box-sizing:border-box;margin:0 auto;max-width:720px;padding:0 25px;width:100%;"><header style="display:inline-block;padding:105px 0 70px;width:100%;"><a class="william-stafford-parsons-icon" href="/"><img src="/icon-william-stafford-parsons.jpg"></a></header><main style="min-height:280px;width:100%;"><h1>WSP-Hash-OAAT: The Fastest OAAT Hashing Algorithm With Good Quality</h1><div class="section"><p class="no-margin-bottom"><a href="/about/">William Stafford Parsons</a> developed a tiny 32-bit OAAT hashing algorithm as a substantial improvement to 32-bit FNV-1a and MicroOAAT.</p></div><div class="section"><h2>Library</h2><h3 class="no-margin-top">Source</h3><code>#include &lt;stdint.h&gt;

struct wsp_hash_oaat_s {
  uint32_t _state;
  uint32_t state;
};

uint32_t wsp_hash_oaat(unsigned long input_count, const uint8_t *input) {
  uint32_t _state = 1;
  uint32_t state = 1111111111;
  unsigned long i = 0;

  while (i != input_count) {
    state ^= input[i];
    state += state << 3;
    _state += state;
    _state = (_state << 27) | (_state >> 5);
    i++;
  }

  state ^= _state;
  state = (_state ^ state) + ((state << 10) | (state >> 22));
  return ((_state << 27) | (_state >> 5)) + state;
}

void wsp_hash_oaat_initialize(struct wsp_hash_oaat_s *s) {
  s->_state = 1;
  s->state = 1111111111;
}

void wsp_hash_oaat_transform(unsigned long i, unsigned long input_count,
                             const uint8_t *input, struct wsp_hash_oaat_s *s) {
  while (i != input_count) {
    s->state ^= input[i];
    s->state += s->state << 3;
    s->_state += s->state;
    s->_state = (s->_state << 27) | (s->_state >> 5);
    i++;
  }
}

void wsp_hash_oaat_finalize(struct wsp_hash_oaat_s *s) {
  s->state ^= s->_state;
  s->state = (s->_state ^ s->state) + ((s->state << 10) | (s->state >> 22));
  s->state += (s->_state << 27) | (s->_state >> 5);
}</code><h3>Reference</h3><p><span class="code">wsp_hash_oaat()</span> is the all-at-once hashing function that accepts the 2 following arguments.</p><p><span class="code">input_count</span> is the count of elements in the <span class="code">input</span> array.</p><p><span class="code">input</span> is the <span class="code">const uint8_t</span> array to hash.</p><p>The return value data type is <span class="code">uint32_t</span>.</p><p>It returns the 32-bit unsigned integer hash digest result.</p><p><span class="code no-margin-left">wsp_hash_oaat_initialize()</span> is the initialization function that accepts the following argument.</p><p><span class="code no-margin-left">s</span> is a <span class="code">struct wsp_hash_oaat_s</span> pointer.</p><p><span class="code no-margin-left">wsp_hash_oaat_transform()</span> is the core hashing loop function that accepts the 4 following arguments.</p><p><span class="code no-margin-left">i</span> is the starting index position of elements in the <span class="code">input</span> array.</p><p><span class="code no-margin-left">input_count</span> is the count of elements in the <span class="code">input</span> array.</p><p><span class="code no-margin-left">input</span> is the <span class="code">const uint8_t</span> array to hash.</p><p><span class="code no-margin-left">s</span> is a <span class="code">struct wsp_hash_oaat_s</span> pointer.</p><p><span class="code no-margin-left">wsp_hash_oaat_finalize()</span> is the finalization function that accepts the following argument.</p><p><span class="code no-margin-left">s</span> is a <span class="code">struct wsp_hash_oaat_s</span> pointer. <span class="code">s.state</span> contains the finalized hash digest result.</p><p>The return value data type is <span class="code">void</span>.</p><h3>Requirements</h3><p>C compiler with C99 (ISO/IEC 9899:1999) standard compatibility.</p><p class="no-margin-bottom">CPU with single-threaded, instruction-level parallelism support.</p></div><div class="section"><h2>Explanation</h2><p>This 32-bit one-at-a-time hashing algorithm is designed to hash keys in data structures in place of existing 32-bit FNV-1a and MicroOAAT implementations.</p><p>It's a lossless performance and statistical quality improvement for all input sizes larger than 3 bytes.</p><p>Input sizes less than or equal to 3 bytes are slower by a small margin with higher statistical quality.</p><p>It's portable for both 32-bit and 64-bit systems.</p><p>It meets strict compliance, portability and code security requirements.</p><p>It doesn't use modulus, multiplication or division arithmetic operations.</p><p>Seed tests are omitted to discourage using one-at-a-time hashing algorithms as PRNGs and to prevent collision vulnerabilities from 2³² different initialized states.</p><p>The core hashing loop structure appears similar to MicroOAAT due to the limited options when designing the fastest non-multiplicative, one-at-a-time hashing function with good collision avoidance, but the technical difference is vast.</p><p>It uses a XOR assignment operation for each input byte instead of an addition assignment, similar to FNV-1a. The remaining operations emulate multiplication before finalizing with enhanced bit distribution.</p><p>Any bitwise multiplication with a left shift operand greater than <span class="code"><< 3</span> is too slow in the core hashing loop and anything less doesn't result in enough distribution to omit a second bitwise multiplication.</p><p>It left-rotates bits in <span class="code">_state</span> instead of right-rotating bits in <span class="code">state</span>.</p><p><span class="code">_state</span> combines with <span class="code">state</span> using addition instead of subtraction to keep bits rolling in the same direction.</p><p>Furthermore, the bit rotation is non-blocking with instruction-level parallelism for each next byte iteration.</p><p>The speed gains from these design differences allow for a minimal finalization sequence with finely-tuned shift values and additive bit rotations in both directions.</p><p>The result deprecates the usage of 32-bit FNV-1a and MicroOAAT by comparison in most practical instances.</p><p>There are significant improvements across all SMHasher tests with no critical collision vulnerabilities relative to the compared hashing algorithms.</p><p>Compared to 32-bit FNV-1a, it's 53% faster on average for small inputs and up to 70% faster on average for large inputs.</p><p>Compared to MicroOAAT, it's 13% faster on average for small inputs and up to 45% faster on average for large inputs.</p><p>It's a practical alternative to Jenkin's OAAT and Murmur OAAT as well with significant collision and speed improvements similar to the aforementioned comparisons.</p><p class="no-margin-bottom">All speed tests were performed locally on a Pixelbook Go M3 using Debian.</p></div><div class="no-margin-bottom section"><h2>Games</h2><div class="game no-margin-bottom no-margin-top"><a href="/contrivity/">Contrivity</a><img alt="Contrivity Icon" src="/icon-contrivity.jpg"><h3>Contrivity</h3><p>Spawn into the hostile quantum laboratory and destroy wave after wave of oscillations.</p></div></div></main><footer><div class="no-margin-bottom"><p>&copy; 2024 William Stafford Parsons</p><ul><li><a href="/about/">About</a></li><li><a href="/contact/">Contact</a></li><li><a href="/#games">Games</a></li><li><a href="/#research">Research</a></li></ul><ul class="social-media"><li><a href="https://github.com/williamstaffordparsons" target="_blank"><img src="/icon-github.jpg"></a></li></ul><p style="color:#777;font-size:12px;line-height:19px;margin:52px 0 0;">All depictions of peril in games by William Stafford Parsons are for fictional gaming entertainment purposes only. Some of the aforementioned games may have frantic animations which may cause discomfort and seizures for players with epilepsy or other sensitivity disorders. Prolongued periods of looking at a computer screen and typing on a keyboard are discouraged to prevent health issues such as carpal tunnel syndrome.</p></div></footer></div></body></html>
