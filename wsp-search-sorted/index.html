<!DOCTYPE html><html lang="en"><head><title>WSP-Search-Sorted</title><link href="https://williamstaffordparsons.github.io/wsp-search-sorted/" rel="canonical"><link href="/favicon.ico?1111111111" rel="icon" type="image/x-icon"><meta content="initial-scale=1,width=device-width" name="viewport"><meta charset="utf-8"><style type="text/css">a{color:#000;font-weight:bold;letter-spacing:-0.1px;text-decoration:none;transition:opacity 0.2s ease;}a:hover{opacity:0.9;}body,html{background:#fafafa;color:#000;font-family:sans-serif;font-size:14px;font-weight:normal;line-height:23px;margin:0;overflow-x:hidden;width:100%;}code{background:#f3f3f3 !important;border:2px solid #bcbcbc !important;border-radius:4px;box-sizing:border-box !important;color:#222;display:inline-block;font-family:monospace !important;font-size:11px;font-weight:normal;height:auto;line-height:18px !important;margin:6px 0 16px;max-height:800px;overflow-x:scroll;padding:30px 31px 25px !important;white-space:pre;width:100% !important;}footer{display:inline-block;margin:100px 0;width:100%;}footer ul{display:inline-block;}footer ul{margin:55px 0 0;padding:0;width:100%;}footer ul li{display:inline-block;float:left;line-height:18px;margin:0 15px 5px 0;}footer ul li a{font-size:12px;float:left;}footer .social-media a{display:block;float:left;}footer .social-media a img{height:16px;}h1,h2,h3{display:inline-block;font-weight:normal;text-transform:uppercase;width:100%;}h1{font-size:23px;letter-spacing:-0.7px;line-height:32px;margin:-6px 0 29px;}h2{font-size:19px;letter-spacing:-0.6px;line-height:42px;margin:0 0 16px;padding-top:18px;}h3{font-size:14px;letter-spacing:-0.2px;margin:13px 0 20px;}p{box-sizing:border-box;color:#555;display:inline-block;margin:0 0 15px;width:100%;}p .code,ul .code{background:#f3f3f3;border:2px solid #bcbcbc;border-radius:4px;color:#222;display:inline-block;font-family:monospace;font-size:11px;font-weight:normal;line-height:16px;margin:2px 1px;padding:4px 5px 0;}ul{list-style:none;margin:0;padding:0;}ul li{color:#555;margin-bottom:15px;}.game{background:#000;border-radius:5px;box-sizing:border-box;margin:0 0 30px;padding:21px 32px;position:relative;transition:opacity 0.2s ease;}.game:hover {opacity:0.9;}.game.no-margin-top{margin-top:5px !important;}.game a{border-radius:5px;height:100%;left:0;position:absolute;text-indent:-9999px;top:0;width:100%;}.game img{display:block;height:32px;margin:12px 0 0;width:32px;}.game h3{color:#fff;font-weight:bold;line-height:30px;margin:17px 0 0;}.game p{color:#999;margin-bottom:0;}.game .version{color:#f02222;display:block;font-size:12px;font-weight:bold;margin:5px 0 3px;}.no-margin-bottom{margin-bottom:0 !important;}.no-margin-left{margin-left:0 !important;}.no-margin-top{margin-top:0 !important;}.section{margin-bottom:40px;position:relative;}.william-stafford-parsons-icon{float:left;margin:0 15px 9px 0;}.william-stafford-parsons-icon img{float:left;height:32px !important;margin:-3px 0 0;}</style></head><body><div style="box-sizing:border-box;margin:0 auto;max-width:720px;padding:0 25px;width:100%;"><header style="display:inline-block;padding:105px 0 70px;width:100%;"><a class="william-stafford-parsons-icon" href="/"><img src="/icon-william-stafford-parsons.jpg"></a></header><main style="min-height:280px;width:100%;"><h1>WSP-Search-Sorted: A Fast Search Algorithm Derived from Optimized Binary Search With Fewer Comparisons To Condense Bounds on Average</h1><div class="section"><p class="no-margin-bottom"><a href="/about/">William Stafford Parsons</a> developed an optimal search algorithm as a substantial improvement to Binary Search, Exponential Search, Fibonnaci Search, Interpolation Search and other sorted-list search algorithms.</p></div><div class="section"><h2>Library</h2><h3 class="no-margin-top">Source</h3><code>#include &lt;stdbool.h&gt;

bool wsp_search_sorted_ascending(unsigned long low, unsigned long high,
                                 unsigned short *haystack,
                                 unsigned short needle,
                                 unsigned long *position) {
  unsigned long _gap;
  unsigned long gap;

  if (haystack[high] == needle) {
    *position = high;
    return true;
  }

  if (
    haystack[low] < needle &&
    haystack[high] > needle
  ) {
    high--;
    gap = high - low;

    while (
      haystack[high] != needle &&
      gap > 1
    ) {
      _gap = high >> 3;

      if (
        _gap > low &&
        haystack[_gap] >= needle
      ) {
        high = _gap;
        gap = high - low;

        while (
          haystack[high] < needle &&
          gap > 1
        ) {
          high += gap >> 1;
          gap = (gap + 1) >> 1;
        }
      } else {
        while (
          haystack[high] > needle &&
          gap > 1
        ) {
          high -= gap >> 1;
          gap = (gap + 1) >> 1;
        }

        while (
          haystack[high] < needle &&
          gap > 1
        ) {
          high += gap >> 1;
          gap = (gap + 1) >> 1;
        }
      }
    }

    low = high;
  }

  if (haystack[low] == needle) {
    *position = low;
    return true;
  }

  return false;
}

bool wsp_search_sorted_descending(unsigned long low, unsigned long high,
                                  unsigned short *haystack,
                                  unsigned short needle,
                                  unsigned long *position) {
  unsigned long _gap;
  unsigned long gap;

  if (haystack[high] == needle) {
    *position = high;
    return true;
  }

  if (
    haystack[low] > needle &&
    haystack[high] < needle
  ) {
    high--;
    gap = high - low;

    while (
      haystack[high] != needle &&
      gap > 1
    ) {
      _gap = high >> 3;

      if (
        _gap > low &&
        haystack[_gap] <= needle
      ) {
        high = _gap;
        gap = high - low;

        while (
          haystack[high] > needle &&
          gap > 1
        ) {
          high += gap >> 1;
          gap = (gap + 1) >> 1;
        }
      } else {
        while (
          haystack[high] < needle &&
          gap > 1
        ) {
          high -= gap >> 1;
          gap = (gap + 1) >> 1;
        }

        while (
          haystack[high] > needle &&
          gap > 1
        ) {
          high += gap >> 1;
          gap = (gap + 1) >> 1;
        }
      }
    }

    low = high;
  }

  if (haystack[low] == needle) {
    *position = low;
    return true;
  }

  return false;
}</code><h3>Reference</h3><p><span class="code no-margin-left">wsp_search_sorted_ascending()</span> is the searching function for a list of elements sorted in ascending order that accepts the following 5 arguments.</p><p><span class="code no-margin-left">low</span> is the lowest index bound to search in <span class="code">haystack</span>.</p><p><span class="code no-margin-left">high</span> is the highest index bound to search in <span class="code">haystack</span>.</p><p>The <span class="code">low</span> value must be less than or equal to the <span class="code">high</span> value and both must be valid indices in <span class="code">haystack</span>.</p><p><span class="code no-margin-left">haystack</span> is the <span class="code">unsigned short</span> array of elements to search. The data type is interchangeable with any integral data type.</p><p><span class="code no-margin-left">needle</span> is the <span class="code">unsigned short</span> element to search for in <span class="code no-margin-left">haystack</span>. The data type should match the <span class="code">haystack</span> data type.</p><p><span class="code no-margin-left">position</span> is the <span class="code">unsigned long</span> pointer containing the index of the searched element.</p><p>The return value data type is <span class="code">bool</span>.</p><p>When the return value is <span class="code">true</span>, <span class="code">position</span> contains the index of the found <span class="code">needle</span>.</p><p>When the return value is <span class="code">false</span>, a new index value isn't assigned to <span class="code">position</span>.</p><p><span class="code no-margin-left">wsp_search_sorted_descending()</span> is the searching function for a list of elements sorted in descending order that accepts the following 5 arguments.</p><p><span class="code no-margin-left">low</span> is the lowest index bound to search in <span class="code">haystack</span>.</p><p><span class="code no-margin-left">high</span> is the highest index bound to search in <span class="code">haystack</span>.</p><p>The <span class="code">low</span> value must be less than or equal to the <span class="code">high</span> value and both must be valid indices in <span class="code">haystack</span>.</p><p><span class="code no-margin-left">haystack</span> is the <span class="code">unsigned short</span> array of elements to search. The data type is interchangeable with any integral data type.</p><p><span class="code no-margin-left">needle</span> is the <span class="code">unsigned short</span> element to search for in <span class="code no-margin-left">haystack</span>. The data type should match the <span class="code">haystack</span> data type.</p><p><span class="code no-margin-left">position</span> is the <span class="code">unsigned long</span> pointer containing the index of the searched element.</p><p>The return value data type is <span class="code">bool</span>.</p><p>When the return value is <span class="code">true</span>, <span class="code">position</span> contains the index of the found <span class="code">needle</span>.</p><p>When the return value is <span class="code">false</span>, a new index value isn't assigned to <span class="code">position</span>.</p><h3>Requirements</h3><p class="no-margin-bottom">C compiler with C99 (ISO/IEC 9899:1999) standard compatibility.</p></div><div class="section"><h2>Explanation</h2><p>WSP-Search-Sorted is designed to speed up Binary Search by decreasing the average number of comparisons with a heuristic based on both <span class="code">high</span> and <span class="code">low</span> bound values instead of <span class="code">haystack</span> element values.</p><p>It's portable for both 32-bit and 64-bit systems.</p><p>It meets strict compliance, portability and security requirements.</p><p>It doesn't use modulus, multiplication or division arithmetic operations.</p><p>In the rare instance where the sort order is unknown, the following <span class="code">wsp_search_sorted()</span> function searches in either ascending or descending order as a convenience with a marginal performance tradeoff.</p><code>#include &lt;stdbool.h&gt;

bool wsp_search_sorted(unsigned long low, unsigned long high,
                       unsigned short *haystack,
                       unsigned short needle, unsigned long *position) {
  unsigned long _gap;
  unsigned long gap;

  if (haystack[high] == needle) {
    *position = high;
    return true;
  }

  if (
    (
      haystack[low] < needle &&
      haystack[high] > needle
    ) ||
    (
      haystack[low] > needle &&
      haystack[high] < needle
    )
  ) {
    high--;
    gap = high - low;

    if (haystack[low] < needle) {
      while (
        haystack[high] != needle &&
        gap > 1
      ) {
        _gap = high >> 3;

        if (
          _gap > low &&
          haystack[_gap] >= needle
        ) {
          high = _gap;
          gap = high - low;

          while (
            haystack[high] < needle &&
            gap > 1
          ) {
            high += gap >> 1;
            gap = (gap + 1) >> 1;
          }
        } else {
          while (
            haystack[high] > needle &&
            gap > 1
          ) {
            high -= gap >> 1;
            gap = (gap + 1) >> 1;
          }

          while (
            haystack[high] < needle &&
            gap > 1
          ) {
            high += gap >> 1;
            gap = (gap + 1) >> 1;
          }
        }
      }
    } else {
      while (
        haystack[high] != needle &&
        gap > 1
      ) {
        _gap = high >> 3;

        if (
          _gap > low &&
          haystack[_gap] <= needle
        ) {
          high = _gap;
          gap = high - low;

          while (
            haystack[high] > needle &&
            gap > 1
          ) {
            high += gap >> 1;
            gap = (gap + 1) >> 1;
          }
        } else {
          while (
            haystack[high] < needle &&
            gap > 1
          ) {
            high -= gap >> 1;
            gap = (gap + 1) >> 1;
          }

          while (
            haystack[high] > needle &&
            gap > 1
          ) {
            high += gap >> 1;
            gap = (gap + 1) >> 1;
          }
        }
      }
    }

    low = high;
  }

  if (haystack[low] == needle) {
    *position = low;
    return true;
  }

  return false;
}</code><p>In each iteration, the <span class="code">high</span> bound jumps ahead with <span class="code">high >> 3</span> whenever it doesn't exceed the position of the <span class="code">needle</span> element.</p><p>After decreasing the <span class="code">high</span> bound whenever the result is within the searching bounds, it performs a binary search in the opposite direction instead of wasting cycles in the same direction, presuming the <span class="code">needle</span> element is among the remaining 87.5% unsearched elements.</p><p>When the result isn't within the searching bounds, segmented <span class="code">while</span> loops traverse in both directions until either the position of the <span class="code">needle</span> element is reached or the <span class="code">gap</span> is decreased to <span class="code">1</span>.</p><p>This jump decreases the number of gap calculations and comparisons in the average instance without slowing down other instances.</p><p>Compared to other sorted-list search algorithms, it's 1% to 20% faster on average across a range of data types and data, both randomized and uniform.</p><p class="no-margin-bottom">Interpolation Search isn't recommended as some of the worst test instances were found trivially with speeds that were 90% slower on average. This significant tradeoff isn't worth the marginal speed gains in specific instances.</p></div><div class="no-margin-bottom section"><h2>Games</h2><div class="game no-margin-bottom no-margin-top"><a href="/contrivity/">Contrivity</a><img alt="Contrivity Icon" src="/icon-contrivity.jpg"><h3>Contrivity</h3><p>Spawn into the hostile quantum laboratory and destroy wave after wave of oscillations.</p><span class="version">v1.0.17</span></div></div></main><footer><div class="no-margin-bottom"><p>&copy; 2024 William Stafford Parsons</p><ul><li><a href="/about/">About</a></li><li><a href="/contact/">Contact</a></li><li><a href="/#games">Games</a></li><li><a href="/#research">Research</a></li></ul><ul class="social-media"><li><a href="https://github.com/williamstaffordparsons" target="_blank"><img src="/icon-github.jpg"></a></li><li><a href="https://www.instagram.com/williamstaffordparsons" target="_blank"><img src="/icon-instagram.jpg"></a></li></ul><p style="color:#777;font-size:12px;line-height:19px;margin:52px 0 0;">All depictions of peril in games by William Stafford Parsons are for fictional gaming entertainment purposes only. Some of the aforementioned games may have frantic animations which may cause discomfort and seizures for players with epilepsy or other sensitivity disorders. Prolongued periods of looking at a computer screen and typing on a keyboard are discouraged to prevent health issues such as carpal tunnel syndrome.</p></div></footer></div></body></html>
